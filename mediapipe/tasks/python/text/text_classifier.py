# Copyright 2022 The MediaPipe Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""MediaPipe text classifier task."""

import ctypes
import dataclasses
from typing import List, Optional
from mediapipe.tasks.python.components.containers import category as category_module
from mediapipe.tasks.python.components.containers import classification_result as classification_result_module
from mediapipe.tasks.python.components.containers import classification_result_c as classification_result_c_module
from mediapipe.tasks.python.components.processors import classifier_options as classifier_options_module
from mediapipe.tasks.python.components.processors import classifier_options_c as classifier_options_c_module
from mediapipe.tasks.python.core import base_options as base_options_module
from mediapipe.tasks.python.core import base_options_c as base_options_c_module
from mediapipe.tasks.python.core import mediapipe_c_bindings as mediapipe_c_bindings_c_module

_BaseOptions = base_options_module.BaseOptions
Category = category_module.Category
Classifications = classification_result_module.Classifications
TextClassifierResult = classification_result_module.ClassificationResult
ClassifierOptions = classifier_options_module.ClassifierOptions


class TextClassifierOptionsC(ctypes.Structure):
  _fields_ = [
      ("base_options", base_options_c_module.BaseOptionsC),
      ("classifier_options", classifier_options_c_module.ClassifierOptionsC),
  ]


@dataclasses.dataclass
class TextClassifierOptions:
  """Options for the text classifier task.

  Attributes:
    base_options: Base options for the text classifier task.
    display_names_locale: The locale to use for display names specified through
      the TFLite Model Metadata.
    max_results: The maximum number of top-scored classification results to
      return.
    score_threshold: Overrides the ones provided in the model metadata. Results
      below this value are rejected.
    category_allowlist: Allowlist of category names. If non-empty,
      classification results whose category name is not in this set will be
      filtered out. Duplicate or unknown category names are ignored. Mutually
      exclusive with `category_denylist`.
    category_denylist: Denylist of category names. If non-empty, classification
      results whose category name is in this set will be filtered out. Duplicate
      or unknown category names are ignored. Mutually exclusive with
      `category_allowlist`.
  """
  base_options: _BaseOptions
  display_names_locale: Optional[str] = None
  max_results: Optional[int] = None
  score_threshold: Optional[float] = None
  category_allowlist: Optional[List[str]] = None
  category_denylist: Optional[List[str]] = None

  def to_ctypes(self) -> TextClassifierOptionsC:
    """Generates a ctypes TextClassifierOptionsC."""
    base_options_c = self.base_options.to_ctypes()
    classifier_options_c = (
        classifier_options_c_module.convert_to_classifier_options_c(
            classifier_options_module.ClassifierOptions(
                display_names_locale=self.display_names_locale,
                max_results=self.max_results,
                score_threshold=self.score_threshold,
                category_allowlist=self.category_allowlist,
                category_denylist=self.category_denylist,
            )
        )
    )

    c_options = TextClassifierOptionsC()
    c_options.base_options = base_options_c
    c_options.classifier_options = classifier_options_c
    return c_options


def _register_ctypes_signatures(lib: ctypes.CDLL):
  """Defines the ctypes signatures for the TextClassifier C API."""
  lib.text_classifier_create.argtypes = [
      ctypes.POINTER(TextClassifierOptionsC),
      ctypes.POINTER(ctypes.c_char_p),
  ]
  lib.text_classifier_create.restype = ctypes.c_void_p
  lib.text_classifier_classify.argtypes = [
      ctypes.c_void_p,
      ctypes.c_char_p,
      ctypes.POINTER(classification_result_c_module.ClassificationResultC),
      ctypes.POINTER(ctypes.c_char_p),
  ]
  lib.text_classifier_classify.restype = ctypes.c_int
  lib.text_classifier_close.argtypes = [
      ctypes.c_void_p,
      ctypes.POINTER(ctypes.c_char_p),
  ]
  lib.text_classifier_close.restype = ctypes.c_int
  lib.text_classifier_close_result.argtypes = [
      ctypes.POINTER(classification_result_c_module.ClassificationResultC)
  ]
  lib.text_classifier_close_result.restype = None


class TextClassifier:
  """Class that performs classification on text.

  This API expects a TFLite model with (optional) TFLite Model Metadata that
  contains the mandatory (described below) input tensors, output tensor,
  and the optional (but recommended) category labels as AssociatedFiles with
  type
  TENSOR_AXIS_LABELS per output classification tensor. Metadata is required for
  models with int32 input tensors because it contains the input process unit
  for the model's Tokenizer. No metadata is required for models with string
  input tensors.

  Input tensors:
    (kTfLiteInt32)
    - 3 input tensors of size `[batch_size x bert_max_seq_len]` representing
      the input ids, segment ids, and mask ids
    - or 1 input tensor of size `[batch_size x max_seq_len]` representing the
      input ids
    or (kTfLiteString)
    - 1 input tensor that is shapeless or has shape [1] containing the input
      string
  At least one output tensor with:
    (kTfLiteFloat32/kBool)
    - `[1 x N]` array with `N` represents the number of categories.
    - optional (but recommended) category labels as AssociatedFiles with type
      TENSOR_AXIS_LABELS, containing one label per line. The first such
      AssociatedFile (if any) is used to fill the `category_name` field of the
      results. The `display_name` field is filled from the AssociatedFile (if
      any) whose locale matches the `display_names_locale` field of the
      `TextClassifierOptions` used at creation time ("en" by default, i.e.
      English). If none of these are available, only the `index` field of the
      results will be filled.
  """
  _lib: ctypes.CDLL
  _handle: ctypes.c_void_p

  def __init__(self, lib: ctypes.CDLL, handle: ctypes.c_void_p):
    self._lib = lib
    self._classifier_handle = handle

  @classmethod
  def create_from_model_path(cls, model_path: str) -> "TextClassifier":
    """Creates an `TextClassifier` object from a TensorFlow Lite model and the default `TextClassifierOptions`.

    Args:
      model_path: Path to the model.

    Returns:
      `TextClassifier` object that's created from the model file and the
      default `TextClassifierOptions`.

    Raises:
      ValueError: If failed to create `TextClassifier` object from the provided
        file such as invalid file path.
      RuntimeError: If other types of error occurred.
    """
    return cls.create_from_options(
        TextClassifierOptions(
            base_options=_BaseOptions(model_asset_path=model_path)
        )
    )

  @classmethod
  def create_from_options(
      cls, options: TextClassifierOptions
  ) -> "TextClassifier":
    """Creates the `TextClassifier` object from text classifier options.

    Args:
      options: Options for the text classifier task.

    Returns:
      `TextClassifier` object that's created from `options`.

    Raises:
      ValueError: If failed to create `TextClassifier` object from
        `TextClassifierOptions` such as missing the model.
      RuntimeError: If other types of error occurred.
    """
    lib = mediapipe_c_bindings_c_module.load_shared_library()  # pylint: disable=protected-access
    _register_ctypes_signatures(lib)

    ctypes_options = options.to_ctypes()

    error_msg_ptr = ctypes.c_char_p()
    classifier_handle = lib.text_classifier_create(
        ctypes.byref(ctypes_options),
        ctypes.byref(error_msg_ptr),
    )

    if classifier_handle is None or classifier_handle == 0:
      if error_msg_ptr.value:  # pylint: disable=using-constant-test
        error_message = error_msg_ptr.value.decode("utf-8")
        raise RuntimeError(error_message)
      else:
        raise RuntimeError("Failed to create TextClassifier object.")

    return TextClassifier(lib=lib, handle=classifier_handle)

  def classify(self, text: str) -> TextClassifierResult:
    """Performs classification on the input `text`.

    Args:
      text: The input text.

    Returns:
      A `TextClassifierResult` object that contains a list of text
      classifications.

    Raises:
      ValueError: If any of the input arguments is invalid.
      RuntimeError: If text classification failed to run.
    """
    ctypes_result = classification_result_c_module.ClassificationResultC()
    error_msg_ptr = ctypes.c_char_p()

    return_code = self._lib.text_classifier_classify(
        self._classifier_handle,
        text.encode("utf-8"),
        ctypes.byref(ctypes_result),
        ctypes.byref(error_msg_ptr),
    )

    if return_code != 0:
      if error_msg_ptr.value is not None:
        error_message = error_msg_ptr.value.decode("utf-8")
        raise RuntimeError(error_message)
      else:
        raise RuntimeError("Classification failed: Unknown error.")

    python_result = TextClassifierResult.from_ctypes(ctypes_result)
    self._lib.text_classifier_close_result(ctypes.byref(ctypes_result))
    return python_result

  def close(self):
    """Shuts down the MediaPipe task instance."""
    if self._classifier_handle:
      error_msg_ptr = ctypes.c_char_p()
      return_code = self._lib.text_classifier_close(
          self._classifier_handle, ctypes.byref(error_msg_ptr)
      )
      if return_code != 0:
        if error_msg_ptr.value is not None:
          error_message = error_msg_ptr.value.decode("utf-8")
          raise RuntimeError(error_message)
        else:
          raise RuntimeError("Failed to close TextClassifier object.")
      self._classifier_handle = None

  def __enter__(self):
    """Returns `self` upon entering the runtime context."""
    return self

  def __exit__(self, unused_exc_type, unused_exc_value, unused_traceback):
    """Shuts down the MediaPipe task instance on exit of the context manager.

    Raises:
      RuntimeError: If the MediaPipe TextClassifier task failed to close.
    """
    self.close()
